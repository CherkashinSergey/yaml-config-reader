/*
 * Example libyaml parser.
 *
 * This is a basic example to demonstrate how to convert yaml to raw data
 * using the libyaml emitter API. Example yaml data to be parsed:
 *
 *    $ cat fruit.yaml
 *    ---
 *    fruit:
 *    - name: apple
 *      color: red
 *      count: 12
 *    - name: orange
 *      color: orange
 *      count: 3
 *    - name: bannana
 *      color: yellow
 *      count: 4
 *    - name: mango
 *      color: green
 *      count: 1
 *    ...
 *
 *    $ ./parse < fruit.yaml
 *    data[0]={name=apple, color=red, count=12}
 *    data[1]={name=orange, color=orange, count=3}
 *    data[2]={name=bannana, color=yellow, count=4}
 *    data[3]={name=mango, color=green, count=1}
 *
 * See the libyaml project page http://pyyaml.org/wiki/LibYAML
 */
#include <yaml.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>



/* Pipe config structure */
//typedef struct buffer_config {
//    size_t size;
//    size_t events_count;
//} buffer_config;

typedef struct stage_config {
    int             workers_count;
    //buffer_config  *buffer;
} stage_config;

typedef struct pipe_config {
    char *name;
    int   count;
//    stage_config *transform;
//    stage_config *output;
} pipe_config;

/* Our example parser states. */
//enum state_value {
//    START,
//    ACCEPT_SECTION,
//    ACCEPT_LIST,
//    ACCEPT_VALUES,
//    ACCEPT_KEY,
//    ACCEPT_VALUE,
//    STOP,
//    ERROR,
//};

enum state_value {
    START,
    ACCEPT_PIPELINE,
    FINISH_PIPELINE,
    ACCEPT_KEY,
    ACCEPT_VALUE,
    STOP,
    ERROR
};

struct parser_state {
    enum state_value state;
    int accepted;
    int error;
    char *key;
    char *value;
    pipe_config data;
};

/*
 * Consume yaml events generated by the libyaml parser to
 * import our data into raw c data structures. Error processing
 * is keep to a mimimum since this is just an example.
 *
 * The expected sequence of events is:
 *
 *    stream ::= STREAM-START document* STREAM-END
 *    document ::= DOCUMENT-START section* DOCUMENT-END
 *    section ::= MAPPING-START (key list) MAPPING-END
 *    list ::= SEQUENCE-START values* SEQUENCE-END
 *    values ::= MAPPING-START (key value)* MAPPING-END
 *    key = SCALAR
 *    value = SCALAR
 */

int consume_event(struct parser_state *s, yaml_event_t *event)
{
    s->accepted = 0;
    switch (s->state) {
    case START:
    case FINISH_PIPELINE:
        switch (event->type) {
        case YAML_STREAM_START_EVENT:
            /* Parser initialized. */
        case YAML_DOCUMENT_START_EVENT:
            /* Document opened. */
        case YAML_SEQUENCE_START_EVENT:
            /* List of pipelines started. */

            break;
        case YAML_MAPPING_START_EVENT:
            s->state = ACCEPT_PIPELINE;
            /* TODO: allocate memory for new pipeline config. */
            break;
        case YAML_STREAM_END_EVENT:
            s->state = STOP;
            break;
        default:
            break;
        }
        break;
    case ACCEPT_PIPELINE:
        /* Pipeline config starts with key name. */
    case ACCEPT_KEY:
        switch (event->type) {
        case YAML_SCALAR_EVENT:
            s->key = strdup((char*)event->data.scalar.value);
            s->state = ACCEPT_VALUE;
            break;
        case YAML_MAPPING_END_EVENT:
            /* Pileline options are finished. */
            s->state = FINISH_PIPELINE;
            s->accepted = 1;
            break;
        default:
            fprintf(stderr, "Unexpected event while getting key: %d\n",
                    event->type);
            s->state = ERROR;
            break;
        }
        break;
    case ACCEPT_VALUE:
        switch (event->type) {
            case YAML_SCALAR_EVENT:
            s->value = (char*)event->data.scalar.value;
            if (strcmp(s->key, "pipeline_name") == 0) {
                s->data.name = strdup((char*)s->value);
            } else if (strcmp(s->key, "count") == 0) {
                s->data.count = atoi(s->value);
            } else {
                fprintf(stderr, "Ignoring unknown key: %s\n", s->key);
            }
            free(s->key);
            s->state = ACCEPT_KEY;
            break;
        default:
            fprintf(stderr, "Unexpected event while getting value: %d\n",
                    event->type);
            s->state = ERROR;
            break;
        }
        break;
    case ERROR:
    case STOP:
        break;
    }
    return (s->state == ERROR ? 0 : 1);
}

int parse_config(char *config_path)
{
    yaml_parser_t parser;
    yaml_event_t event;
    struct parser_state state = {.state=START, .accepted=0, .error=0};
    pipe_config data[64];
    int i = 0;

    FILE *fptr = fopen(config_path,"r");

    memset(data, 0, sizeof(data));
    yaml_parser_initialize(&parser);
    yaml_parser_set_input_file(&parser, fptr);

    do {
        if (!yaml_parser_parse(&parser, &event)) {
            goto error;
        }
        if (!consume_event(&state, &event)) {
            goto error;
        }
        if (state.accepted && i < sizeof(data)/sizeof(*data)) {
            data[i].name = state.data.name;
            data[i].count = state.data.count;
            printf("data[%d]={name=%s, count=%d}\n",
                i, data[i].name, data[i].count);
            i++;
        }
        yaml_event_delete(&event);
    } while (state.state != STOP);

    yaml_parser_delete(&parser);
    return 0;

error:
    yaml_parser_delete(&parser);
    return 1;
}

int main(int argc, char *argv[])
{
    parse_config("config.yml");

    return 0;
}
